---
title: "JavaScript Stack Traces & Source Maps — Debugging in Production"
slug: "monitoring-js-stack-traces-sourcemaps"
category: "Monitoring"
tags: ["monitoring", "debugging", "sourcemaps", "stack trace", "javascript"]
summary: "Stack traces help debug runtime errors, but in production, they're often minified and useless. Learn how to map stack traces to original source with source maps and interpret them effectively."
publishedAt: "2024-01-24"
---

# JavaScript Stack Traces & Source Maps — Debugging in Production

You deploy your frontend. Something crashes. The error logs show:

```
TypeError at main.min.js:1:9281
```

...and you have no idea what it means.

Welcome to debugging minified JavaScript in production.

To make sense of it, you need **stack traces** and **source maps** — your two best allies for understanding and fixing real-world JavaScript errors.

---

## What is a Stack Trace?

A **stack trace** is a snapshot of the call stack at the moment an error occurs.

It shows:
- Function names
- File names
- Line and column numbers
- Call hierarchy (who called what)

Example:

```js
TypeError: Cannot read properties of undefined
    at getProduct (ProductCard.tsx:45:12)
    at renderCard (Feed.tsx:112:8)
    at runEffect (React)
```

This tells you:
- What failed (`getProduct`)
- Where it failed (`ProductCard.tsx:45`)
- The context of the call

---

## The Problem with Production Code

In production:
- JavaScript is **minified**
- Function names are shortened or removed
- Code is transpiled (TypeScript → JS, JSX → JS)

You end up with unreadable traces:

```
at o (main.min.js:1:9281)
at t (main.min.js:1:8473)
```

To decode this, you need **source maps**.

---

## What Are Source Maps?

Source maps are JSON files that map **minified code back to the original source**.

They allow error logging tools and debuggers to:
- Show original filenames
- Show original line/column positions
- Reconstruct meaningful stack traces

They're generated by bundlers like:
- Webpack
- Rollup
- esbuild
- Vite

---

## Generating Source Maps

### Webpack

```js
module.exports = {
  devtool: 'source-map', // for full, production-safe maps
};
```

### Vite

```js
build: {
  sourcemap: true
}
```

### Terser

Even minifiers can inline sourcemaps:

```bash
terser main.js -o main.min.js --source-map
```

---

## Publishing Source Maps

You can:
- Upload to a third-party service (Sentry, Bugsnag, Raygun)
- Serve alongside your JS files (e.g., `main.js.map`)
- Keep private and use only for internal debugging

### Best Practice

Keep maps **private** — or strip sensitive code/comments — to avoid leaking logic.

---

## Capturing Stack Traces

Use:

```js
window.onerror = function (msg, url, line, col, error) {
  console.error(error.stack);
};

window.onunhandledrejection = function (event) {
  console.error(event.reason.stack);
};
```

Send the stack + metadata to your backend.

---

## Tools That Use Source Maps

- **Sentry**
- **Bugsnag**
- **LogRocket**
- **Raygun**
- Chrome DevTools (for sourcemap-enabled debugging)

---

## Real-World Example: Sentry

1. App crashes → JS error sent to Sentry
2. Stack trace includes file + line + column
3. Sentry uses uploaded `.map` files to reverse map
4. Shows source code context around the failure

No more guesswork — just readable, actionable info.

---

## Obfuscation vs Minification

- **Minification**: Shortens and compresses code
- **Obfuscation**: Actively hides logic (anti-reverse-engineering)

Source maps work with both — but beware:
- Obfuscated code + maps = leaked IP

---

## Anti-Patterns

- Deploying with `devtool: 'eval'` or no maps
- Exposing sourcemaps publicly without permission
- Forgetting to upload maps to error tracker
- Minifying with aggressive mangling of function names (hurts stack readability)

---

## Conclusion: Make Stack Traces Human Again

A broken app in production isn’t just a bug — it’s a crisis you can’t understand without the right tools.

Stack traces tell you **what broke**. Source maps tell you **where and why**.

Together, they make error logging **debuggable, actionable, fixable**.

So don’t log noise. Log clarity.

And let your stack traces speak your code’s true voice.

